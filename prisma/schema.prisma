generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Admin {
  id           Int      @id @default(autoincrement()) @db.UnsignedInt
  encName      String // AES-encrypted admin name
  nameIndex    String   @unique // sha256(lowercase username)
  passwordHash String // Argon2 hash
  allowedIp    String // Bound admin IP
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model User {
  id               Int       @id @default(autoincrement())
  openid           String    @unique
  wechatNick       String?
  avatarUrl        String?
  realNameVerified Boolean   @default(false)
  birthDate        DateTime?
  age              Int?
  ageGroup         AgeGroup  @default(ADULT)
  canParticipate   Boolean   @default(true)
  canBuyMembership Boolean   @default(true)
  totalRewardsCent Int       @default(0) @db.UnsignedInt
  city             String?
  joinCount        Int    @default(3) @db.UnsignedInt
  prizeMultiplier  Int    @default(1) @db.UnsignedInt
  referralCode     String?    @unique
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  membership          Membership?
  referralsMade       Referral[]          @relation("referrer")
  referralsGot        Referral[]          @relation("referee")
  entries             ContestEntry[]
  prizeClaims         ContestPrizeClaim[]
  consents            UserConsent[]
  userSteps           UserSteps?
}

model UserConsent {
  id         Int           @id @default(autoincrement())
  userId     Int
  policyType ConsentPolicy
  policyVer  String
  acceptedAt DateTime      @default(now())
  user       User          @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([userId, policyType])
}

model UserSteps {
  id            Int           @id @default(autoincrement())
  userId        Int           @unique
  stepInfoList  String?        @db.LongText
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([userId])
}

enum ConsentPolicy {
  TERMS
  PRIVACY
  LIABILITY
}

enum AgeGroup {
  MINOR_12_18
  ADULT
  SENIOR_60_65
  SENIOR_65_PLUS
  BLOCKED_UNDER_12
}

model Referral {
  id         Int      @id @default(autoincrement())
  referrerId Int
  refereeId  Int      @unique
  createdAt  DateTime @default(now())
  verified   Int      @default(0)

  referrer User @relation("referrer", fields: [referrerId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  referee  User @relation("referee", fields: [refereeId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@unique([referrerId, refereeId])
  @@index([referrerId])
  @@index([refereeId])
}

enum CreditSource {
  MONTHLY_FREE
  MEMBERSHIP
  REFERRAL
  AD_REWARD
  ADMIN
}

enum MembershipTier {
  BRONZE
  SILVER
  GOLD
}

enum MembershipDuring {
  MONTHLY
  ANNUAL
}

model MembershipTierInfo {
  id           Int           @id @default(autoincrement())
  level        MembershipTier     @unique
  during       MembershipDuring
  price        Int

  memberships  Membership[]
}


model Membership {
  id           Int            @id @default(autoincrement())
  userId       Int            @unique
  tierLevel    MembershipTier
  startAt      DateTime
  endAt        DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  tier MembershipTierInfo @relation( fields: [tierLevel],  references: [level],  onDelete: Restrict, onUpdate: Cascade )

  @@index([userId])
  @@index([tierLevel])
}


model Contest {
  id         Int             @id @default(autoincrement())
  title      String
  scope      RegionLevel
  regionCode String
  frequency  ContestFreq
  audience   ContestAudience @default(ADULTS)
  status     ContestStatus   @default(SCHEDULED)
  startAt    DateTime
  endAt      DateTime
  createdAt  DateTime        @default(now())
  updatedAt  DateTime        @updatedAt

  region           Region              @relation("ContestRegion", fields: [regionCode], references: [code], onDelete: Restrict, onUpdate: Cascade) // ðŸ‘ˆ named
  entries          ContestEntry[]
  leaderboard      Leaderboard?
  prizeClaims      ContestPrizeClaim[]
  contestPrizeRule ContestPrizeRule[]

  @@index([status, startAt])
  @@index([regionCode, frequency, status])
}

model Region {
  code      String      @id
  name      String
  level     RegionLevel
  parent    String?
  heatLevel  Int?
  createdAt DateTime    @default(now())

  contests Contest[] @relation("ContestRegion") // ðŸ‘ˆ back relation

  @@index([level])
  @@index([parent])
}

enum RegionLevel {
  NONE
  CITY
  PROVINCE
  DISTRICT
}

enum ContestFreq {
  DAILY
  WEEKLY
  MONTHLY
}

enum ContestAudience {
  ADULTS
  YOUTH
}

enum ContestStatus {
  SCHEDULED
  ONGOING
  FINALIZING
  FINALIZED
  CANCELED
}

model ContestEntry {
  id               Int          @id @default(autoincrement())
  userId           Int
  contestId        Int
  steps            Int          @default(0)
  submittedAt      DateTime     @default(now())

  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  contest        Contest      @relation(fields: [contestId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  
  @@unique([userId, contestId])
  @@index([contestId, steps])
  @@index([submittedAt])
  @@index([userId, submittedAt])
}

enum EntryStatus {
  PENDING
  VERIFIED
  REJECTED
}

model Leaderboard {
  id            Int      @id @default(autoincrement())
  contestId     Int      @unique
  finalizedAt   DateTime
  topJson       String   @db.LongText
  backupJson    String   @db.LongText
  integrityHash String   @db.LongText
  createdAt     DateTime @default(now())

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([finalizedAt])
}

enum PrizeClaimStatus {
  PENDING
  COMPLETED
  REJECTED
}

model ContestPrizeRule {
  id        Int @id @default(autoincrement())
  contestId Int
  rankStart Int
  rankEnd   Int
  prizeValueCent   Int

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)

  @@index([contestId, rankStart, rankEnd])
}

model ServiceAgent {
  id        Int      @id @default(autoincrement())
  name      String
  wechatId  String?  @unique
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  assignedClaims ContestPrizeClaim[]

  @@index([isActive])
}

model ContestPrizeClaim {
  id                  Int              @id @default(autoincrement())
  contestId           Int
  userId              Int
  rank                Int
  steps               Int
  prizeValueCent      Int?
  assignedAgentId     Int?
  status              PrizeClaimStatus @default(PENDING)
  useMultiple         Boolean @default(false)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  contest        Contest       @relation(fields: [contestId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  assignedAgent  ServiceAgent? @relation(fields: [assignedAgentId], references: [id], onDelete: SetNull, onUpdate: Cascade)

  @@unique([contestId, userId]) // -> where: { contestId_userId: { â€¦ } }
  @@index([userId, status])
  @@index([contestId, status])
  @@index([assignedAgentId])
}

